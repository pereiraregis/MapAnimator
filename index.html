<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Map Animator PRO - Trim Paths Edition</title>
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; display: flex; background: #0f0f0f; color: #ececec; height: 100vh; width: 100vw; overflow: hidden; }
        .sidebar { position: absolute; left: 0; top: 0; width: 380px; height: 100%; padding: 20px; box-sizing: border-box; border-right: 1px solid #333; background: rgba(26, 26, 26, 0.98); overflow-y: auto; z-index: 9999; box-shadow: 10px 0 30px rgba(0,0,0,0.5); }
        #map-viewport { flex-grow: 1; position: relative; display: flex; align-items: center; justify-content: center; background: #000; width: 100vw; height: 100vh; overflow: hidden; }
        #map-container { position: relative; transform-origin: center center; background: #000; flex-shrink: 0; width: 1920px; height: 1080px; }
        #map { width: 100%; height: 100%; }
        .maplibregl-ctrl-attrib, .maplibregl-ctrl-logo { display: none !important; }
        .section-title { font-size: 11px; font-weight: 800; color: #3b82f6; text-transform: uppercase; margin: 20px 0 10px 0; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .card { background: #252525; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #3b82f6; position: relative; }
        label { display: block; font-size: 9px; color: #888; margin-bottom: 2px; text-transform: uppercase; font-weight: 700; }
        input, select, button { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #333; background: #111; color: white; margin-bottom: 5px; font-size: 12px; }
        .flex-row { display: flex; gap: 5px; align-items: flex-end; }
        button { background: #3b82f6; border: none; font-weight: 600; cursor: pointer; transition: 0.2s; }
        button:hover { background: #2563eb; }
        .btn-remove { background: #991b1b; width: 20px; height: 20px; position: absolute; right: 8px; top: 8px; border-radius: 50%; padding: 0; line-height: 18px; }
        .progress-bar { height: 4px; background: #10b981; width: 0%; margin-top: 8px; }
        .maplibregl-marker { z-index: 100; will-change: transform; transform-style: preserve-3d; backface-visibility: hidden; }
        .pin-style-modern { color: white; padding: 6px 14px; border-radius: 50px; font-size: 13px; font-weight: 700; white-space: nowrap; border: 2px solid #ffffff; background-clip: padding-box; filter: drop-shadow(0px 4px 6px rgba(0,0,0,0.5)); transform: translate3d(-50%, -100%, 0); }
        .pin-style-dot { width: 14px; height: 14px; border: 2.5px solid #ffffff; border-radius: 50%; filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.5)); transform: translate3d(-50%, -50%, 0); }
        .pin-label-dot { position: absolute; left: 22px; background: rgba(0,0,0,0.85); padding: 4px 8px; border-radius: 4px; color: white; white-space: nowrap; border: 1px solid #444; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <h2 style="margin:0 0 10px 0;">Map Animator PRO</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 15px;">
        <button onclick="saveProject()">Save JSON</button>
        <button onclick="document.getElementById('loadInput').click()">Load JSON</button>
        <input type="file" id="loadInput" style="display:none" onchange="loadProject(this)" accept=".json">
    </div>

    <div class="section-title">Draw Path - Trim Effect</div>
    <div class="flex-row">
        <button id="drawBtn" onclick="toggleDrawing()" style="background:#4b5563">Activate Draw Mode</button>
        <button onclick="clearPath()" style="background:#991b1b">Clear Line</button>
    </div>
    <label>Line Color</label>
    <input type="color" id="path-color" value="#F72210" onchange="syncPathLayer()">

    <div class="section-title">Camera Path</div>
    <div id="points-list"></div>
    <button onclick="addWaypoint()">+ Add Waypoint</button>

    <div class="section-title">Visual Pins</div>
    <div id="pins-list"></div>
    <button style="background:#F72210" onclick="addPin()">+ Add Pin (#F72210)</button>

    <div class="section-title">Settings</div>
    <label>Interpolação</label>
    <select id="easing-type">
        <option value="easeInOutCubic">Ease In Out - Smooth</option>
        <option value="linear">Linear - Constant</option>
    </select>
    <div class="flex-row">
        <div style="flex:1"><label>Secs/Leg</label><input type="number" id="duration" value="3"></div>
        <div style="flex:1"><label>FPS</label><input type="number" id="fps" value="30"></div>
    </div>
    
    <button id="startBtn" style="background:#10b981; margin-top:15px; padding:12px;" onclick="generateZip()">RENDER SEQUENCE (1920px)</button>
    <div id="status-text" style="color:#10b981; font-size:11px; margin-top:10px;">Ready.</div>
    <div style="background:#333; height:4px; margin-top:5px;"><div id="progress" style="height:100%; width:0%; background:#10b981;"></div></div>
</div>

<div id="map-viewport">
    <div id="map-container"><div id="map"></div></div>
</div>

<script>
    let waypoints = [];
    let pins = [];
    let customPathCoords = [];
    let isDrawing = false;

    const easings = { 
        easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
        linear: t => t 
    };

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://tiles.openfreemap.org/styles/bright',
        center: [-46.633, -23.550], zoom: 12,
        preserveDrawingBuffer: true, antialias: true, attributionControl: false
    });

    map.on('load', () => {
        map.getStyle().layers.forEach(l => { if (l.id.includes('poi') || l.id.includes('place')) map.removeLayer(l.id); });
        
        map.addSource('route-source', {
            type: 'geojson',
            data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] } }
        });

        map.addLayer({
            id: 'route-line',
            type: 'line',
            source: 'route-source',
            paint: {
                'line-color': '#F72210',
                'line-width': 5,
                'line-dasharray': [2, 2]
            }
        });

        updateViewport();
    });

    function toggleDrawing() {
        isDrawing = !isDrawing;
        const btn = document.getElementById('drawBtn');
        btn.style.background = isDrawing ? '#10b981' : '#4b5563';
        btn.innerText = isDrawing ? 'Clique no Mapa' : 'Ativar Desenho';
        map.getCanvas().style.cursor = isDrawing ? 'crosshair' : '';
    }

    map.on('click', (e) => {
        if (!isDrawing) return;
        customPathCoords.push([e.lngLat.lng, e.lngLat.lat]);
        syncPathLayer();
    });

    function syncPathLayer(partialCoords = null) {
        const color = document.getElementById('path-color').value;
        const coords = partialCoords || customPathCoords;
        map.setPaintProperty('route-line', 'line-color', color);
        map.getSource('route-source').setData({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: coords.length > 1 ? coords : [] }
        });
    }

    function clearPath() { customPathCoords = []; syncPathLayer(); }

    function updateViewport() {
        const vp = document.getElementById('map-viewport');
        const cont = document.getElementById('map-container');
        const scale = Math.min((vp.clientWidth - 40) / 1920, (vp.clientHeight - 40) / 1080);
        cont.style.transform = `scale(${scale})`;
        map.resize();
    }
    window.addEventListener('resize', updateViewport);

    function addPin() {
        const pin = { id: Date.now(), ...map.getCenter(), text: "Novo Local", style: "pin-style-modern", color: "#F72210" };
        createPinMarker(pin);
        pins.push(pin);
        renderUI();
    }

    function createPinMarker(pin) {
        if (pin.marker) pin.marker.remove();
        const el = document.createElement('div');
        el.className = pin.style;
        el.style.backgroundColor = (pin.style === 'pin-style-clean') ? 'transparent' : pin.color;
        el.innerHTML = pin.style === 'pin-style-dot' ? `<div class="pin-label-dot">${pin.text}</div>` : pin.text;
        pin.marker = new maplibregl.Marker({ element: el, draggable: true }).setLngLat([pin.lng, pin.lat]).addTo(map);
        pin.marker.on('dragend', () => { const l = pin.marker.getLngLat(); pin.lng = l.lng; pin.lat = l.lat; });
    }

    function updatePin(id, field, value) {
        const pin = pins.find(p => p.id === id);
        if (pin) { pin[field] = value; createPinMarker(pin); renderUI(); }
    }

    async function captureFrame() {
        const cont = document.getElementById('map-container');
        const sidebar = document.getElementById('sidebar');
        const originalTransform = cont.style.transform;
        sidebar.style.visibility = 'hidden'; 
        cont.style.transform = 'none';
        map.triggerRepaint();
        await new Promise(r => map.once('idle', r));
        const canvas = await html2canvas(cont, { useCORS: true, scale: 1, width: 1920, height: 1080, backgroundColor: '#000', logging: false });
        cont.style.transform = originalTransform;
        sidebar.style.visibility = 'visible'; 
        return canvas.toDataURL('image/png', 1.0).split(',')[1];
    }

    // Função auxiliar para interpolar pontos da linha (Trim Path)
    function getTrimmedPath(coords, progress) {
        if (coords.length < 2) return coords;
        if (progress >= 1) return coords;
        
        let totalDist = 0;
        let segmentDists = [];
        for (let i = 0; i < coords.length - 1; i++) {
            let d = Math.sqrt(Math.pow(coords[i+1][0]-coords[i][0], 2) + Math.pow(coords[i+1][1]-coords[i][1], 2));
            segmentDists.push(d);
            totalDist += d;
        }

        let targetDist = totalDist * progress;
        let currentDist = 0;
        let newCoords = [coords[0]];

        for (let i = 0; i < segmentDists.length; i++) {
            if (currentDist + segmentDists[i] <= targetDist) {
                newCoords.push(coords[i+1]);
                currentDist += segmentDists[i];
            } else {
                let remain = (targetDist - currentDist) / segmentDists[i];
                let lastLng = coords[i][0] + (coords[i+1][0] - coords[i][0]) * remain;
                let lastLat = coords[i][1] + (coords[i+1][1] - coords[i][1]) * remain;
                newCoords.push([lastLng, lastLat]);
                break;
            }
        }
        return newCoords;
    }

    async function generateZip() {
        if (waypoints.length < 2) return alert("Min 2 Waypoints");
        const btn = document.getElementById('startBtn'); btn.disabled = true;
        const zip = new JSZip();
        const fps = parseInt(document.getElementById('fps').value);
        const durPerLeg = parseFloat(document.getElementById('duration').value);
        const framesPerLeg = Math.ceil(durPerLeg * fps);
        const totalFrames = framesPerLeg * (waypoints.length - 1);
        const easingFunc = easings[document.getElementById('easing-type').value];
        let totalIdx = 0;

        for (let p = 0; p < waypoints.length - 1; p++) {
            const A = waypoints[p], B = waypoints[p+1];
            for (let i = 0; i < framesPerLeg; i++) {
                const legT = i / framesPerLeg;
                const easedLegT = easingFunc(legT);
                
                // Progresso global para o efeito Trim (0 a 1 em toda a animação)
                // Conclui em 90% do tempo total
                const globalProgress = Math.min(1, (totalIdx / totalFrames) / 0.9);

                map.jumpTo({
                    center: [A.lng + (B.lng-A.lng)*easedLegT, A.lat + (B.lat-A.lat)*easedLegT],
                    zoom: A.zoom + (B.zoom-A.zoom)*easedLegT,
                    pitch: A.pitch + (B.pitch-A.pitch)*easedLegT,
                    bearing: A.bearing + (B.bearing-A.bearing)*easedLegT
                });

                // Atualiza o rastro da linha (Trim Path)
                if (customPathCoords.length > 1) {
                    const currentVisiblePath = getTrimmedPath(customPathCoords, globalProgress);
                    syncPathLayer(currentVisiblePath);
                }

                const img = await captureFrame();
                zip.file(`frame_${totalIdx.toString().padStart(5, '0')}.png`, img, {base64: true});
                totalIdx++;
                document.getElementById('progress').style.width = (totalIdx/totalFrames*100) + "%";
            }
        }
        const blob = await zip.generateAsync({type:"blob"});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "render_1920_trim.zip"; a.click();
        btn.disabled = false;
        syncPathLayer(); // Restaura linha completa no editor
    }

    function addWaypoint() {
        const c = map.getCenter();
        waypoints.push({ id: Date.now(), lat: c.lat, lng: c.lng, zoom: map.getZoom(), pitch: map.getPitch(), bearing: map.getBearing() });
        renderUI();
    }

    function updateWaypoint(id) {
        const idx = waypoints.findIndex(w => w.id === id);
        const c = map.getCenter();
        waypoints[idx] = { ...waypoints[idx], lat: c.lat, lng: c.lng, zoom: map.getZoom(), pitch: map.getPitch(), bearing: map.getBearing() };
        alert("Waypoint atualizado!");
    }

    async function exportSingle(idx) {
        const w = waypoints[idx];
        map.jumpTo({ center: [w.lng, w.lat], zoom: w.zoom, pitch: w.pitch, bearing: w.bearing });
        await new Promise(r => setTimeout(r, 500));
        const img = await captureFrame();
        const a = document.createElement('a'); a.href = 'data:image/png;base64,'+img; a.download=`waypoint_${idx}.png`; a.click();
    }

    function renderUI() {
        document.getElementById('points-list').innerHTML = waypoints.map((w,i) => `
            <div class="card">
                <label>Waypoint ${i+1}</label>
                <div class="flex-row">
                    <button onclick="updateWaypoint(${w.id})">Update</button>
                    <button onclick="exportSingle(${i})">PNG</button>
                    <button class="btn-remove" onclick="waypoints.splice(${i},1);renderUI()">×</button>
                </div>
            </div>`).join('');
        document.getElementById('pins-list').innerHTML = pins.map((p,i) => `
            <div class="card">
                <input type="text" value="${p.text}" oninput="updatePin('${p.id}', 'text', this.value)">
                <div class="flex-row">
                    <select onchange="updatePin('${p.id}', 'style', this.value)" style="flex:2">
                        <option value="pin-style-modern" ${p.style==='pin-style-modern'?'selected':''}>Bubble</option>
                        <option value="pin-style-dot" ${p.style==='pin-style-dot'?'selected':''}>Dot</option>
                    </select>
                    <input type="color" value="${p.color}" oninput="updatePin('${p.id}', 'color', this.value)" style="flex:1; height:32px; padding:2px">
                </div>
                <button class="btn-remove" onclick="pins.splice(${i},1);p.marker.remove();renderUI()">×</button>
            </div>`).join('');
    }

    function saveProject() { 
        const a = document.createElement('a'); 
        a.href = URL.createObjectURL(new Blob([JSON.stringify({waypoints, pins: pins.map(p => ({...p, marker:null})), path: customPathCoords})], {type:"application/json"})); 
        a.download="project.json"; a.click(); 
    }
    
    function loadProject(input) { 
        const r = new FileReader(); 
        r.onload = (e) => { 
            const d = JSON.parse(e.target.result); 
            waypoints = d.waypoints; 
            pins.forEach(p=>p.marker?.remove()); pins=[]; 
            d.pins.forEach(p => { createPinMarker(p); pins.push(p); }); 
            if(d.path) customPathCoords = d.path;
            if(waypoints.length > 0) map.jumpTo({ center: [waypoints[0].lng, waypoints[0].lat], zoom: waypoints[0].zoom, pitch: waypoints[0].pitch, bearing: waypoints[0].bearing });
            syncPathLayer(); renderUI(); updateViewport(); 
        }; 
        r.readAsText(input.files[0]); 
    }
</script>
</body>
</html>